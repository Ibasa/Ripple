// This file is auto generated by GenerateDefinitions, do not edit by hand
using System;
using System.Buffers;
using System.Collections.ObjectModel;
using System.Text.Json;
using Ibasa.Ripple.St;
namespace Ibasa.Ripple.St
{
    /// <summary>
    /// The type of a transaction (TransactionType field) is the most fundamental information about a transaction.
    /// This indicates what type of operation the transaction is supposed to do.
    /// </summary>
    public enum StTransactionType : ushort
    {
        Invalid = 65535,
        Payment = 0,
        EscrowCreate = 1,
        EscrowFinish = 2,
        AccountSet = 3,
        EscrowCancel = 4,
        SetRegularKey = 5,
        NickNameSet = 6,
        OfferCreate = 7,
        OfferCancel = 8,
        Contract = 9,
        TicketCreate = 10,
        TicketCancel = 11,
        SignerListSet = 12,
        PaymentChannelCreate = 13,
        PaymentChannelFund = 14,
        PaymentChannelClaim = 15,
        CheckCreate = 16,
        CheckCash = 17,
        CheckCancel = 18,
        DepositPreauth = 19,
        TrustSet = 20,
        AccountDelete = 21,
        EnableAmendment = 100,
        SetFee = 101,
        UNLModify = 102,
    }

    /// <summary>
    /// Map of ledger objects to their data type.
    /// These appear in ledger state data, and in the "affected nodes" section of processed transactions' metadata.
    /// </summary>
    public enum StLedgerEntryType
    {
        Any = -3,
        Child = -2,
        Invalid = -1,
        AccountRoot = 97,
        DirectoryNode = 100,
        RippleState = 114,
        Ticket = 84,
        SignerList = 83,
        Offer = 111,
        LedgerHashes = 104,
        Amendments = 102,
        FeeSettings = 115,
        Escrow = 117,
        PayChannel = 120,
        DepositPreauth = 112,
        Check = 67,
        Nickname = 110,
        Contract = 99,
        GeneratorMap = 103,
        NegativeUNL = 78,
    }

    /// <summary>
    /// Map of data types to their "type code" for constructing field IDs and sorting fields in canonical order.
    /// Codes below 1 should not appear in actual data;
    /// codes above 10000 represent special "high-level" object types such as "Transaction" that cannot be serialized inside other objects.
    /// See the Type List for details of how to serialize each type.
    /// </summary>
    public enum StTypeCode
    {
        Validation = 10003,
        Done = -1,
        Hash128 = 4,
        Blob = 7,
        AccountID = 8,
        Amount = 6,
        Hash256 = 5,
        UInt8 = 16,
        Vector256 = 19,
        Object = 14,
        Unknown = -2,
        Transaction = 10001,
        Hash160 = 17,
        PathSet = 18,
        LedgerEntry = 10002,
        UInt16 = 1,
        NotPresent = 0,
        UInt64 = 3,
        UInt32 = 2,
        Array = 15,
    }

    public enum StAccountIDFieldCode
    {
        Account = 1,
        Authorize = 5,
        Destination = 3,
        Issuer = 4,
        Owner = 2,
        RegularKey = 8,
        Target = 7,
        Unauthorize = 6,
    }

    public enum StAmountFieldCode
    {
        Amount = 1,
        Balance = 2,
        DeliverMin = 10,
        DeliveredAmount = 18,
        Fee = 8,
        HighLimit = 7,
        LimitAmount = 3,
        LowLimit = 6,
        MinimumOffer = 16,
        RippleEscrow = 17,
        SendMax = 9,
        TakerGets = 5,
        TakerPays = 4,
        TakerGetsFunded = 258,
        TakerPaysFunded = 259,
    }

    public enum StArrayFieldCode
    {
        AffectedNodes = 8,
        ArrayEndMarker = 1,
        DisabledValidators = 17,
        Majorities = 16,
        Memos = 9,
        Necessary = 6,
        SignerEntries = 4,
        Signers = 3,
        Sufficient = 7,
        Template = 5,
    }

    public enum StBlobFieldCode
    {
        Condition = 17,
        CreateCode = 11,
        Domain = 7,
        ExpireCode = 10,
        Fulfillment = 16,
        FundCode = 8,
        Generator = 5,
        MasterSignature = 18,
        MemoData = 13,
        MemoFormat = 14,
        MemoType = 12,
        MessageKey = 2,
        PublicKey = 1,
        RemoveCode = 9,
        Signature = 6,
        SigningPubKey = 3,
        TxnSignature = 4,
        UNLModifyValidator = 19,
        ValidatorToDisable = 20,
        ValidatorToReEnable = 20,
    }

    public enum StHash128FieldCode
    {
        EmailHash = 1,
    }

    public enum StHash160FieldCode
    {
        TakerGetsCurrency = 3,
        TakerGetsIssuer = 4,
        TakerPaysCurrency = 1,
        TakerPaysIssuer = 2,
    }

    public enum StHash256FieldCode
    {
        AccountHash = 4,
        AccountTxnID = 9,
        Amendment = 19,
        BookDirectory = 16,
        Channel = 22,
        CheckID = 24,
        ConsensusHash = 23,
        Digest = 21,
        InvoiceID = 17,
        LedgerHash = 1,
        LedgerIndex = 6,
        Nickname = 18,
        ParentHash = 2,
        PreviousTxnID = 5,
        RootIndex = 8,
        TicketID = 20,
        TransactionHash = 3,
        WalletLocator = 7,
        hash = 257,
        index = 258,
    }

    public enum StLedgerEntryFieldCode
    {
        LedgerEntry = 1,
    }

    public enum StObjectFieldCode
    {
        CreatedNode = 3,
        DeletedNode = 4,
        DisabledValidator = 19,
        FinalFields = 7,
        Majority = 18,
        Memo = 10,
        ModifiedNode = 5,
        NewFields = 8,
        ObjectEndMarker = 1,
        PreviousFields = 6,
        Signer = 16,
        SignerEntry = 11,
        TemplateEntry = 9,
        TransactionMetaData = 2,
    }

    public enum StPathSetFieldCode
    {
        Paths = 1,
    }

    public enum StTransactionFieldCode
    {
        Transaction = 1,
    }

    public enum StUInt16FieldCode
    {
        LedgerEntryType = 1,
        SignerWeight = 3,
        TransactionType = 2,
    }

    public enum StUInt32FieldCode
    {
        BondAmount = 23,
        CancelAfter = 36,
        ClearFlag = 34,
        CloseTime = 7,
        DestinationTag = 14,
        Expiration = 10,
        FinishAfter = 37,
        FirstLedgerSequence = 26,
        Flags = 2,
        HighQualityIn = 16,
        HighQualityOut = 17,
        LastLedgerSequence = 27,
        LedgerSequence = 6,
        LoadFee = 24,
        LowQualityIn = 18,
        LowQualityOut = 19,
        OfferSequence = 25,
        OperationLimit = 29,
        OwnerCount = 13,
        ParentCloseTime = 8,
        PreviousTxnLgrSeq = 5,
        QualityIn = 20,
        QualityOut = 21,
        ReferenceFeeUnits = 30,
        ReserveBase = 31,
        ReserveIncrement = 32,
        Sequence = 4,
        SetFlag = 33,
        SettleDelay = 39,
        SignerListID = 38,
        SignerQuorum = 35,
        SigningTime = 9,
        SourceTag = 3,
        StampEscrow = 22,
        TicketCount = 40,
        TicketSequence = 41,
        TransactionIndex = 28,
        TransferRate = 11,
        WalletSize = 12,
    }

    public enum StUInt64FieldCode
    {
        BaseFee = 5,
        BookNode = 3,
        DestinationNode = 9,
        ExchangeRate = 6,
        HighNode = 8,
        IndexNext = 1,
        IndexPrevious = 2,
        LowNode = 7,
        OwnerNode = 4,
    }

    public enum StUInt8FieldCode
    {
        CloseResolution = 1,
        Method = 2,
        TickSize = 16,
        TransactionResult = 3,
        UNLModifyDisabling = 17,
    }

    public enum StUnknownFieldCode
    {
        Generic = 0,
        Invalid = -1,
    }

    public enum StValidationFieldCode
    {
        Validation = 1,
    }

    public enum StVector256FieldCode
    {
        Amendments = 3,
        Hashes = 2,
        Indexes = 1,
    }

    public partial struct StFieldId
    {
        public static readonly StFieldId AccountID_Account = new StFieldId(StTypeCode.AccountID, 1);
        public static readonly StFieldId AccountID_Authorize = new StFieldId(StTypeCode.AccountID, 5);
        public static readonly StFieldId AccountID_Destination = new StFieldId(StTypeCode.AccountID, 3);
        public static readonly StFieldId AccountID_Issuer = new StFieldId(StTypeCode.AccountID, 4);
        public static readonly StFieldId AccountID_Owner = new StFieldId(StTypeCode.AccountID, 2);
        public static readonly StFieldId AccountID_RegularKey = new StFieldId(StTypeCode.AccountID, 8);
        public static readonly StFieldId AccountID_Target = new StFieldId(StTypeCode.AccountID, 7);
        public static readonly StFieldId AccountID_Unauthorize = new StFieldId(StTypeCode.AccountID, 6);

        public static readonly StFieldId Amount_Amount = new StFieldId(StTypeCode.Amount, 1);
        public static readonly StFieldId Amount_Balance = new StFieldId(StTypeCode.Amount, 2);
        public static readonly StFieldId Amount_DeliverMin = new StFieldId(StTypeCode.Amount, 10);
        public static readonly StFieldId Amount_DeliveredAmount = new StFieldId(StTypeCode.Amount, 18);
        public static readonly StFieldId Amount_Fee = new StFieldId(StTypeCode.Amount, 8);
        public static readonly StFieldId Amount_HighLimit = new StFieldId(StTypeCode.Amount, 7);
        public static readonly StFieldId Amount_LimitAmount = new StFieldId(StTypeCode.Amount, 3);
        public static readonly StFieldId Amount_LowLimit = new StFieldId(StTypeCode.Amount, 6);
        public static readonly StFieldId Amount_MinimumOffer = new StFieldId(StTypeCode.Amount, 16);
        public static readonly StFieldId Amount_RippleEscrow = new StFieldId(StTypeCode.Amount, 17);
        public static readonly StFieldId Amount_SendMax = new StFieldId(StTypeCode.Amount, 9);
        public static readonly StFieldId Amount_TakerGets = new StFieldId(StTypeCode.Amount, 5);
        public static readonly StFieldId Amount_TakerPays = new StFieldId(StTypeCode.Amount, 4);
        public static readonly StFieldId Amount_taker_gets_funded = new StFieldId(StTypeCode.Amount, 258);
        public static readonly StFieldId Amount_taker_pays_funded = new StFieldId(StTypeCode.Amount, 259);

        public static readonly StFieldId Array_AffectedNodes = new StFieldId(StTypeCode.Array, 8);
        public static readonly StFieldId Array_ArrayEndMarker = new StFieldId(StTypeCode.Array, 1);
        public static readonly StFieldId Array_DisabledValidators = new StFieldId(StTypeCode.Array, 17);
        public static readonly StFieldId Array_Majorities = new StFieldId(StTypeCode.Array, 16);
        public static readonly StFieldId Array_Memos = new StFieldId(StTypeCode.Array, 9);
        public static readonly StFieldId Array_Necessary = new StFieldId(StTypeCode.Array, 6);
        public static readonly StFieldId Array_SignerEntries = new StFieldId(StTypeCode.Array, 4);
        public static readonly StFieldId Array_Signers = new StFieldId(StTypeCode.Array, 3);
        public static readonly StFieldId Array_Sufficient = new StFieldId(StTypeCode.Array, 7);
        public static readonly StFieldId Array_Template = new StFieldId(StTypeCode.Array, 5);

        public static readonly StFieldId Blob_Condition = new StFieldId(StTypeCode.Blob, 17);
        public static readonly StFieldId Blob_CreateCode = new StFieldId(StTypeCode.Blob, 11);
        public static readonly StFieldId Blob_Domain = new StFieldId(StTypeCode.Blob, 7);
        public static readonly StFieldId Blob_ExpireCode = new StFieldId(StTypeCode.Blob, 10);
        public static readonly StFieldId Blob_Fulfillment = new StFieldId(StTypeCode.Blob, 16);
        public static readonly StFieldId Blob_FundCode = new StFieldId(StTypeCode.Blob, 8);
        public static readonly StFieldId Blob_Generator = new StFieldId(StTypeCode.Blob, 5);
        public static readonly StFieldId Blob_MasterSignature = new StFieldId(StTypeCode.Blob, 18);
        public static readonly StFieldId Blob_MemoData = new StFieldId(StTypeCode.Blob, 13);
        public static readonly StFieldId Blob_MemoFormat = new StFieldId(StTypeCode.Blob, 14);
        public static readonly StFieldId Blob_MemoType = new StFieldId(StTypeCode.Blob, 12);
        public static readonly StFieldId Blob_MessageKey = new StFieldId(StTypeCode.Blob, 2);
        public static readonly StFieldId Blob_PublicKey = new StFieldId(StTypeCode.Blob, 1);
        public static readonly StFieldId Blob_RemoveCode = new StFieldId(StTypeCode.Blob, 9);
        public static readonly StFieldId Blob_Signature = new StFieldId(StTypeCode.Blob, 6);
        public static readonly StFieldId Blob_SigningPubKey = new StFieldId(StTypeCode.Blob, 3);
        public static readonly StFieldId Blob_TxnSignature = new StFieldId(StTypeCode.Blob, 4);
        public static readonly StFieldId Blob_UNLModifyValidator = new StFieldId(StTypeCode.Blob, 19);
        public static readonly StFieldId Blob_ValidatorToDisable = new StFieldId(StTypeCode.Blob, 20);
        public static readonly StFieldId Blob_ValidatorToReEnable = new StFieldId(StTypeCode.Blob, 20);

        public static readonly StFieldId Hash128_EmailHash = new StFieldId(StTypeCode.Hash128, 1);

        public static readonly StFieldId Hash160_TakerGetsCurrency = new StFieldId(StTypeCode.Hash160, 3);
        public static readonly StFieldId Hash160_TakerGetsIssuer = new StFieldId(StTypeCode.Hash160, 4);
        public static readonly StFieldId Hash160_TakerPaysCurrency = new StFieldId(StTypeCode.Hash160, 1);
        public static readonly StFieldId Hash160_TakerPaysIssuer = new StFieldId(StTypeCode.Hash160, 2);

        public static readonly StFieldId Hash256_AccountHash = new StFieldId(StTypeCode.Hash256, 4);
        public static readonly StFieldId Hash256_AccountTxnID = new StFieldId(StTypeCode.Hash256, 9);
        public static readonly StFieldId Hash256_Amendment = new StFieldId(StTypeCode.Hash256, 19);
        public static readonly StFieldId Hash256_BookDirectory = new StFieldId(StTypeCode.Hash256, 16);
        public static readonly StFieldId Hash256_Channel = new StFieldId(StTypeCode.Hash256, 22);
        public static readonly StFieldId Hash256_CheckID = new StFieldId(StTypeCode.Hash256, 24);
        public static readonly StFieldId Hash256_ConsensusHash = new StFieldId(StTypeCode.Hash256, 23);
        public static readonly StFieldId Hash256_Digest = new StFieldId(StTypeCode.Hash256, 21);
        public static readonly StFieldId Hash256_InvoiceID = new StFieldId(StTypeCode.Hash256, 17);
        public static readonly StFieldId Hash256_LedgerHash = new StFieldId(StTypeCode.Hash256, 1);
        public static readonly StFieldId Hash256_LedgerIndex = new StFieldId(StTypeCode.Hash256, 6);
        public static readonly StFieldId Hash256_Nickname = new StFieldId(StTypeCode.Hash256, 18);
        public static readonly StFieldId Hash256_ParentHash = new StFieldId(StTypeCode.Hash256, 2);
        public static readonly StFieldId Hash256_PreviousTxnID = new StFieldId(StTypeCode.Hash256, 5);
        public static readonly StFieldId Hash256_RootIndex = new StFieldId(StTypeCode.Hash256, 8);
        public static readonly StFieldId Hash256_TicketID = new StFieldId(StTypeCode.Hash256, 20);
        public static readonly StFieldId Hash256_TransactionHash = new StFieldId(StTypeCode.Hash256, 3);
        public static readonly StFieldId Hash256_WalletLocator = new StFieldId(StTypeCode.Hash256, 7);
        public static readonly StFieldId Hash256_hash = new StFieldId(StTypeCode.Hash256, 257);
        public static readonly StFieldId Hash256_index = new StFieldId(StTypeCode.Hash256, 258);

        public static readonly StFieldId LedgerEntry_LedgerEntry = new StFieldId(StTypeCode.LedgerEntry, 1);

        public static readonly StFieldId Object_CreatedNode = new StFieldId(StTypeCode.Object, 3);
        public static readonly StFieldId Object_DeletedNode = new StFieldId(StTypeCode.Object, 4);
        public static readonly StFieldId Object_DisabledValidator = new StFieldId(StTypeCode.Object, 19);
        public static readonly StFieldId Object_FinalFields = new StFieldId(StTypeCode.Object, 7);
        public static readonly StFieldId Object_Majority = new StFieldId(StTypeCode.Object, 18);
        public static readonly StFieldId Object_Memo = new StFieldId(StTypeCode.Object, 10);
        public static readonly StFieldId Object_ModifiedNode = new StFieldId(StTypeCode.Object, 5);
        public static readonly StFieldId Object_NewFields = new StFieldId(StTypeCode.Object, 8);
        public static readonly StFieldId Object_ObjectEndMarker = new StFieldId(StTypeCode.Object, 1);
        public static readonly StFieldId Object_PreviousFields = new StFieldId(StTypeCode.Object, 6);
        public static readonly StFieldId Object_Signer = new StFieldId(StTypeCode.Object, 16);
        public static readonly StFieldId Object_SignerEntry = new StFieldId(StTypeCode.Object, 11);
        public static readonly StFieldId Object_TemplateEntry = new StFieldId(StTypeCode.Object, 9);
        public static readonly StFieldId Object_TransactionMetaData = new StFieldId(StTypeCode.Object, 2);

        public static readonly StFieldId PathSet_Paths = new StFieldId(StTypeCode.PathSet, 1);

        public static readonly StFieldId Transaction_Transaction = new StFieldId(StTypeCode.Transaction, 1);

        public static readonly StFieldId UInt16_LedgerEntryType = new StFieldId(StTypeCode.UInt16, 1);
        public static readonly StFieldId UInt16_SignerWeight = new StFieldId(StTypeCode.UInt16, 3);
        public static readonly StFieldId UInt16_TransactionType = new StFieldId(StTypeCode.UInt16, 2);

        public static readonly StFieldId UInt32_BondAmount = new StFieldId(StTypeCode.UInt32, 23);
        public static readonly StFieldId UInt32_CancelAfter = new StFieldId(StTypeCode.UInt32, 36);
        public static readonly StFieldId UInt32_ClearFlag = new StFieldId(StTypeCode.UInt32, 34);
        public static readonly StFieldId UInt32_CloseTime = new StFieldId(StTypeCode.UInt32, 7);
        public static readonly StFieldId UInt32_DestinationTag = new StFieldId(StTypeCode.UInt32, 14);
        public static readonly StFieldId UInt32_Expiration = new StFieldId(StTypeCode.UInt32, 10);
        public static readonly StFieldId UInt32_FinishAfter = new StFieldId(StTypeCode.UInt32, 37);
        public static readonly StFieldId UInt32_FirstLedgerSequence = new StFieldId(StTypeCode.UInt32, 26);
        public static readonly StFieldId UInt32_Flags = new StFieldId(StTypeCode.UInt32, 2);
        public static readonly StFieldId UInt32_HighQualityIn = new StFieldId(StTypeCode.UInt32, 16);
        public static readonly StFieldId UInt32_HighQualityOut = new StFieldId(StTypeCode.UInt32, 17);
        public static readonly StFieldId UInt32_LastLedgerSequence = new StFieldId(StTypeCode.UInt32, 27);
        public static readonly StFieldId UInt32_LedgerSequence = new StFieldId(StTypeCode.UInt32, 6);
        public static readonly StFieldId UInt32_LoadFee = new StFieldId(StTypeCode.UInt32, 24);
        public static readonly StFieldId UInt32_LowQualityIn = new StFieldId(StTypeCode.UInt32, 18);
        public static readonly StFieldId UInt32_LowQualityOut = new StFieldId(StTypeCode.UInt32, 19);
        public static readonly StFieldId UInt32_OfferSequence = new StFieldId(StTypeCode.UInt32, 25);
        public static readonly StFieldId UInt32_OperationLimit = new StFieldId(StTypeCode.UInt32, 29);
        public static readonly StFieldId UInt32_OwnerCount = new StFieldId(StTypeCode.UInt32, 13);
        public static readonly StFieldId UInt32_ParentCloseTime = new StFieldId(StTypeCode.UInt32, 8);
        public static readonly StFieldId UInt32_PreviousTxnLgrSeq = new StFieldId(StTypeCode.UInt32, 5);
        public static readonly StFieldId UInt32_QualityIn = new StFieldId(StTypeCode.UInt32, 20);
        public static readonly StFieldId UInt32_QualityOut = new StFieldId(StTypeCode.UInt32, 21);
        public static readonly StFieldId UInt32_ReferenceFeeUnits = new StFieldId(StTypeCode.UInt32, 30);
        public static readonly StFieldId UInt32_ReserveBase = new StFieldId(StTypeCode.UInt32, 31);
        public static readonly StFieldId UInt32_ReserveIncrement = new StFieldId(StTypeCode.UInt32, 32);
        public static readonly StFieldId UInt32_Sequence = new StFieldId(StTypeCode.UInt32, 4);
        public static readonly StFieldId UInt32_SetFlag = new StFieldId(StTypeCode.UInt32, 33);
        public static readonly StFieldId UInt32_SettleDelay = new StFieldId(StTypeCode.UInt32, 39);
        public static readonly StFieldId UInt32_SignerListID = new StFieldId(StTypeCode.UInt32, 38);
        public static readonly StFieldId UInt32_SignerQuorum = new StFieldId(StTypeCode.UInt32, 35);
        public static readonly StFieldId UInt32_SigningTime = new StFieldId(StTypeCode.UInt32, 9);
        public static readonly StFieldId UInt32_SourceTag = new StFieldId(StTypeCode.UInt32, 3);
        public static readonly StFieldId UInt32_StampEscrow = new StFieldId(StTypeCode.UInt32, 22);
        public static readonly StFieldId UInt32_TicketCount = new StFieldId(StTypeCode.UInt32, 40);
        public static readonly StFieldId UInt32_TicketSequence = new StFieldId(StTypeCode.UInt32, 41);
        public static readonly StFieldId UInt32_TransactionIndex = new StFieldId(StTypeCode.UInt32, 28);
        public static readonly StFieldId UInt32_TransferRate = new StFieldId(StTypeCode.UInt32, 11);
        public static readonly StFieldId UInt32_WalletSize = new StFieldId(StTypeCode.UInt32, 12);

        public static readonly StFieldId UInt64_BaseFee = new StFieldId(StTypeCode.UInt64, 5);
        public static readonly StFieldId UInt64_BookNode = new StFieldId(StTypeCode.UInt64, 3);
        public static readonly StFieldId UInt64_DestinationNode = new StFieldId(StTypeCode.UInt64, 9);
        public static readonly StFieldId UInt64_ExchangeRate = new StFieldId(StTypeCode.UInt64, 6);
        public static readonly StFieldId UInt64_HighNode = new StFieldId(StTypeCode.UInt64, 8);
        public static readonly StFieldId UInt64_IndexNext = new StFieldId(StTypeCode.UInt64, 1);
        public static readonly StFieldId UInt64_IndexPrevious = new StFieldId(StTypeCode.UInt64, 2);
        public static readonly StFieldId UInt64_LowNode = new StFieldId(StTypeCode.UInt64, 7);
        public static readonly StFieldId UInt64_OwnerNode = new StFieldId(StTypeCode.UInt64, 4);

        public static readonly StFieldId UInt8_CloseResolution = new StFieldId(StTypeCode.UInt8, 1);
        public static readonly StFieldId UInt8_Method = new StFieldId(StTypeCode.UInt8, 2);
        public static readonly StFieldId UInt8_TickSize = new StFieldId(StTypeCode.UInt8, 16);
        public static readonly StFieldId UInt8_TransactionResult = new StFieldId(StTypeCode.UInt8, 3);
        public static readonly StFieldId UInt8_UNLModifyDisabling = new StFieldId(StTypeCode.UInt8, 17);

        public static readonly StFieldId Unknown_Generic = new StFieldId(StTypeCode.Unknown, 0);
        public static readonly StFieldId Unknown_Invalid = new StFieldId(StTypeCode.Unknown, 4294967295);

        public static readonly StFieldId Validation_Validation = new StFieldId(StTypeCode.Validation, 1);

        public static readonly StFieldId Vector256_Amendments = new StFieldId(StTypeCode.Vector256, 3);
        public static readonly StFieldId Vector256_Hashes = new StFieldId(StTypeCode.Vector256, 2);
        public static readonly StFieldId Vector256_Indexes = new StFieldId(StTypeCode.Vector256, 1);

    }

}
namespace Ibasa.Ripple
{
    /// <summary>
    /// The AccountRoot object type describes a single account, its settings, and XRP balance.
    /// </summary>
    public sealed partial class AccountRoot : LedgerObject
    {
        /// <summary>
        /// The identifying address of this account, such as rf1BiGeXwwQoi8Z2ueFYTEXSwuJYfV2Jpn.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The account's current XRP balance in drops.
        /// </summary>
        public XrpAmount Balance { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags enabled for this account.
        /// </summary>
        public AccountRootFlags Flags { get; private set; }

        /// <summary>
        /// The number of objects this account owns in the ledger, which contributes to its owner reserve.
        /// </summary>
        public uint OwnerCount { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// The sequence number of the next valid transaction for this account. (Each account starts with Sequence = 1 and increases each time a transaction is made.)
        /// </summary>
        public uint Sequence { get; private set; }

        /// <summary>
        /// (Optional) The identifying hash of the transaction most recently sent by this account. This field must be enabled to use the AccountTxnID transaction field. To enable it, send an AccountSet transaction with the asfAccountTxnID flag enabled.
        /// </summary>
        public Hash256? AccountTxnID { get; private set; }

        /// <summary>
        /// (Optional) A domain associated with this account. In JSON, this is the hexadecimal for the ASCII representation of the domain.
        /// </summary>
        public ReadOnlyMemory<byte>? Domain { get; private set; }

        /// <summary>
        /// (Optional) The md5 hash of an email address. Clients can use this to look up an avatar through services such as Gravatar.
        /// </summary>
        public Hash128? EmailHash { get; private set; }

        /// <summary>
        /// (Optional) A public key that may be used to send encrypted messages to this account. In JSON, uses hexadecimal. Must be exactly 33 bytes, with the first byte indicating the key type: 0x02 or 0x03 for secp256k1 keys, 0xED for Ed25519 keys.
        /// </summary>
        public ReadOnlyMemory<byte>? MessageKey { get; private set; }

        /// <summary>
        /// (Optional) The address of a key pair that can be used to sign transactions for this account instead of the master key. Use a SetRegularKey transaction to change this value.
        /// </summary>
        public AccountId? RegularKey { get; private set; }

        /// <summary>
        /// (Optional) How many significant digits to use for exchange rates of Offers involving currencies issued by this address. Valid values are 3 to 15, inclusive. (Added by the TickSize amendment.)
        /// </summary>
        public byte? TickSize { get; private set; }

        /// <summary>
        /// (Optional) A transfer fee to charge other users for sending currency issued by this account to each other.
        /// </summary>
        public uint? TransferRate { get; private set; }

        internal AccountRoot(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "AccountRoot")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"AccountRoot\"", "json");
            }
            JsonElement element;

            Account = new AccountId(json.GetProperty("Account").GetString());
            Balance = XrpAmount.ReadJson(json.GetProperty("Balance"));
            Flags = (AccountRootFlags)json.GetProperty("Flags").GetUInt32();
            OwnerCount = json.GetProperty("OwnerCount").GetUInt32();
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            Sequence = json.GetProperty("Sequence").GetUInt32();
            if (json.TryGetProperty("AccountTxnID", out element))
            {
                AccountTxnID = new Hash256(element.GetString());
            }
            if (json.TryGetProperty("Domain", out element))
            {
                Domain = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("EmailHash", out element))
            {
                EmailHash = new Hash128(element.GetString());
            }
            if (json.TryGetProperty("MessageKey", out element))
            {
                MessageKey = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("RegularKey", out element))
            {
                RegularKey = new AccountId(element.GetString());
            }
            if (json.TryGetProperty("TickSize", out element))
            {
                TickSize = element.GetByte();
            }
            if (json.TryGetProperty("TransferRate", out element))
            {
                TransferRate = element.GetUInt32();
            }
        }

        internal AccountRoot(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = (AccountRootFlags)reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_TransferRate)
            {
                TransferRate = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_OwnerCount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_OwnerCount, fieldId));
            }
            OwnerCount = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Hash128_EmailHash)
            {
                EmailHash = reader.ReadHash128();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Hash256_AccountTxnID)
            {
                AccountTxnID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_Balance)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Balance, fieldId));
            }
            Balance = reader.ReadXrpAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_MessageKey)
            {
                MessageKey = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Blob_Domain)
            {
                Domain = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.AccountID_RegularKey)
            {
                RegularKey = reader.ReadAccount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    return;
                }
            }
            if (fieldId == StFieldId.UInt8_TickSize)
            {
                TickSize = reader.ReadUInt8();
            }
        }

    }

    /// <summary>
    /// The Amendments object type contains a list of Amendments that are currently active. Each ledger version contains at most one Amendments object.
    /// </summary>
    public sealed partial class Amendments : LedgerObject
    {
        /// <summary>
        /// (Optional) Array of 256-bit amendment IDs for all currently-enabled amendments. If omitted, there are no enabled amendments.
        /// </summary>
        public ReadOnlyCollection<Hash256> AmendmentIDs { get; private set; }

        /// <summary>
        /// (Optional) Array of objects describing the status of amendments that have majority support but are not yet enabled. If omitted, there are no pending amendments with majority support.
        /// </summary>
        public ReadOnlyCollection<Majority> Majorities { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags. No flags are defined for the Amendments object type, so this value is always 0.
        /// </summary>
        public uint Flags { get; private set; }

        internal Amendments(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Amendments")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Amendments\"", "json");
            }
            JsonElement element;

            if (json.TryGetProperty("Amendments", out element))
            {
            var AmendmentIDsArray = new Hash256[element.GetArrayLength()];
            for (int i = 0; i < AmendmentIDsArray.Length; ++i)
            {
                AmendmentIDsArray[i] = new Hash256(element[i].GetString());
            }
            AmendmentIDs = Array.AsReadOnly(AmendmentIDsArray);
            }
            if (json.TryGetProperty("Majorities", out element))
            {
            var MajoritiesArray = new Majority[element.GetArrayLength()];
            for (int i = 0; i < MajoritiesArray.Length; ++i)
            {
                MajoritiesArray[i] = new Majority(element[i]);
            }
            Majorities = Array.AsReadOnly(MajoritiesArray);
            }
            Flags = json.GetProperty("Flags").GetUInt32();
        }

        internal Amendments(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                return;
            }
            if (fieldId == StFieldId.Array_Majorities)
            {
                var MajoritiesList = new System.Collections.Generic.List<Majority>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        if (!reader.TryReadFieldId(out fieldId))
                        {
                            return;
                        }
                        break;
                    }
                    if (fieldId != StFieldId.Object_Majority)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_Majority, fieldId));
                    }
                    MajoritiesList.Add(new Majority(ref reader));
                }
                Majorities = MajoritiesList.AsReadOnly();
            }
            if (fieldId == StFieldId.Vector256_Amendments)
            {
                AmendmentIDs = Array.AsReadOnly(reader.ReadVector256());
            }
        }

    }

    /// <summary>
    /// A Check object describes a check, similar to a paper personal check, which can be cashed by its destination to get money from its sender. (The potential payment has already been approved by its sender, but no money moves until it is cashed. Unlike an Escrow, the money for a Check is not set aside, so cashing the Check could fail due to lack of funds.)
    /// </summary>
    public sealed partial class Check : LedgerObject
    {
        /// <summary>
        /// The sender of the Check. Cashing the Check debits this address's balance.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The intended recipient of the Check. Only this address can cash the Check, using a CheckCash transaction.
        /// </summary>
        public AccountId Destination { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags. No flags are defined for Checks, so this value is always 0.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// The maximum amount of currency this Check can debit the sender. If the Check is successfully cashed, the destination is credited in the same currency for up to this amount.
        /// </summary>
        public Amount SendMax { get; private set; }

        /// <summary>
        /// The sequence number of the CheckCreate transaction that created this check.
        /// </summary>
        public uint Sequence { get; private set; }

        /// <summary>
        /// (Optional) A hint indicating which page of the destination's owner directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong? DestinationNode { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the destination for this Check, such as a hosted recipient at the destination address.
        /// </summary>
        public uint? DestinationTag { get; private set; }

        /// <summary>
        /// (Optional) Indicates the time after which this Check is considered expired. See Specifying Time for details.
        /// </summary>
        public DateTimeOffset? Expiration { get; private set; }

        /// <summary>
        /// (Optional) Arbitrary 256-bit hash provided by the sender as a specific reason or identifier for this Check.
        /// </summary>
        public Hash256? InvoiceID { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the source for this Check, such as a hosted recipient at the sender's address.
        /// </summary>
        public uint? SourceTag { get; private set; }

        internal Check(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Check")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Check\"", "json");
            }
            JsonElement element;

            Account = new AccountId(json.GetProperty("Account").GetString());
            Destination = new AccountId(json.GetProperty("Destination").GetString());
            Flags = json.GetProperty("Flags").GetUInt32();
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            SendMax = Amount.ReadJson(json.GetProperty("SendMax"));
            Sequence = json.GetProperty("Sequence").GetUInt32();
            if (json.TryGetProperty("DestinationNode", out element))
            {
                DestinationNode = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
            if (json.TryGetProperty("Expiration", out element))
            {
                Expiration = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("InvoiceID", out element))
            {
                InvoiceID = new Hash256(element.GetString());
            }
            if (json.TryGetProperty("SourceTag", out element))
            {
                SourceTag = element.GetUInt32();
            }
        }

        internal Check(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_Expiration)
            {
                Expiration = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt64_DestinationNode)
            {
                DestinationNode = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Hash256_InvoiceID)
            {
                InvoiceID = reader.ReadHash256();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Amount_SendMax)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_SendMax, fieldId));
            }
            SendMax = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
        }

    }

    /// <summary>
    /// A DepositPreauth object tracks a preauthorization from one account to another. DepositPreauth transactions create these objects.
    /// </summary>
    public sealed partial class DepositPreauth : LedgerObject
    {
        /// <summary>
        /// The account that granted the preauthorization. (The destination of the preauthorized payments.)
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The account that received the preauthorization. (The sender of the preauthorized payments.)
        /// </summary>
        public AccountId Authorize { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags. No flags are defined for DepositPreauth objects, so this value is always 0.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        internal DepositPreauth(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "DepositPreauth")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"DepositPreauth\"", "json");
            }

            Account = new AccountId(json.GetProperty("Account").GetString());
            Authorize = new AccountId(json.GetProperty("Authorize").GetString());
            Flags = json.GetProperty("Flags").GetUInt32();
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
        }

        internal DepositPreauth(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Authorize)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Authorize, fieldId));
            }
            Authorize = reader.ReadAccount();
        }

    }

    /// <summary>
    /// The DirectoryNode object type provides a list of links to other objects in the ledger's state tree. A single conceptual Directory takes the form of a doubly linked list, with one or more DirectoryNode objects each containing up to 32 IDs of other objects. The first object is called the root of the directory, and all objects other than the root object can be added or deleted as necessary.
    /// </summary>
    public sealed partial class DirectoryNode : LedgerObject
    {
        /// <summary>
        /// A bit-map of boolean flags enabled for this directory. Currently, the protocol defines no flags for DirectoryNode objects.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// The ID of root object for this directory.
        /// </summary>
        public Hash256 RootIndex { get; private set; }

        /// <summary>
        /// The contents of this Directory: an array of IDs of other objects.
        /// </summary>
        public ReadOnlyCollection<Hash256> Indexes { get; private set; }

        /// <summary>
        /// (Optional) If this Directory consists of multiple pages, this ID links to the next object in the chain, wrapping around at the end.
        /// </summary>
        public ulong? IndexNext { get; private set; }

        /// <summary>
        /// (Optional) If this Directory consists of multiple pages, this ID links to the previous object in the chain, wrapping around at the beginning.
        /// </summary>
        public ulong? IndexPrevious { get; private set; }

        /// <summary>
        /// (Optional) (Owner Directories only) The address of the account that owns the objects in this directory.
        /// </summary>
        public AccountId? Owner { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) DEPRECATED. Do not use.
        /// </summary>
        public ulong? ExchangeRate { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) The currency code of the TakerPays amount from the offers in this directory.
        /// </summary>
        public CurrencyCode? TakerPaysCurrency { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) The issuer of the TakerPays amount from the offers in this directory.
        /// </summary>
        public AccountId? TakerPaysIssuer { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) The currency code of the TakerGets amount from the offers in this directory.
        /// </summary>
        public CurrencyCode? TakerGetsCurrency { get; private set; }

        /// <summary>
        /// (Optional) (Offer Directories only) The issuer of the TakerGets amount from the offers in this directory.
        /// </summary>
        public AccountId? TakerGetsIssuer { get; private set; }

        internal DirectoryNode(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "DirectoryNode")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"DirectoryNode\"", "json");
            }
            JsonElement element;

            Flags = json.GetProperty("Flags").GetUInt32();
            RootIndex = new Hash256(json.GetProperty("RootIndex").GetString());
            element = json.GetProperty("Indexes");
            var IndexesArray = new Hash256[element.GetArrayLength()];
            for (int i = 0; i < IndexesArray.Length; ++i)
            {
                IndexesArray[i] = new Hash256(element[i].GetString());
            }
            Indexes = Array.AsReadOnly(IndexesArray);
            if (json.TryGetProperty("IndexNext", out element))
            {
                IndexNext = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("IndexPrevious", out element))
            {
                IndexPrevious = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("Owner", out element))
            {
                Owner = new AccountId(element.GetString());
            }
            if (json.TryGetProperty("ExchangeRate", out element))
            {
                ExchangeRate = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("TakerPaysCurrency", out element))
            {
                TakerPaysCurrency = new CurrencyCode(element.GetBytesFromBase16());
            }
            if (json.TryGetProperty("TakerPaysIssuer", out element))
            {
                TakerPaysIssuer = new AccountId(element.GetBytesFromBase16());
            }
            if (json.TryGetProperty("TakerGetsCurrency", out element))
            {
                TakerGetsCurrency = new CurrencyCode(element.GetBytesFromBase16());
            }
            if (json.TryGetProperty("TakerGetsIssuer", out element))
            {
                TakerGetsIssuer = new AccountId(element.GetBytesFromBase16());
            }
        }

        internal DirectoryNode(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt64_IndexNext)
            {
                IndexNext = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt64_IndexPrevious)
            {
                IndexPrevious = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt64_ExchangeRate)
            {
                ExchangeRate = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_RootIndex)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_RootIndex, fieldId));
            }
            RootIndex = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.AccountID_Owner)
            {
                Owner = reader.ReadAccount();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash160_TakerPaysCurrency)
            {
                TakerPaysCurrency = ToCurrencyCode(reader.ReadHash160());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash160_TakerPaysIssuer)
            {
                TakerPaysIssuer = ToAccountId(reader.ReadHash160());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash160_TakerGetsCurrency)
            {
                TakerGetsCurrency = ToCurrencyCode(reader.ReadHash160());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.Hash160_TakerGetsIssuer)
            {
                TakerGetsIssuer = ToAccountId(reader.ReadHash160());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Vector256_Indexes)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Vector256_Indexes, fieldId));
            }
            Indexes = Array.AsReadOnly(reader.ReadVector256());
        }

    }

    /// <summary>
    /// The Escrow object type represents a held payment of XRP waiting to be executed or canceled. An EscrowCreate transaction creates an Escrow object in the ledger.
    /// </summary>
    public sealed partial class Escrow : LedgerObject
    {
        /// <summary>
        /// The address of the owner (sender) of this held payment. This is the account that provided the XRP, and gets it back if the held payment is canceled.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The destination address where the XRP is paid if the held payment is successful.
        /// </summary>
        public AccountId Destination { get; private set; }

        /// <summary>
        /// The amount of XRP, in drops, to be delivered by the held payment.
        /// </summary>
        public Amount Amount { get; private set; }

        /// <summary>
        /// (Optional) A PREIMAGE-SHA-256 crypto-condition , as hexadecimal. If present, the EscrowFinish transaction must contain a fulfillment that satisfies this condition.
        /// </summary>
        public ReadOnlyMemory<byte>? Condition { get; private set; }

        /// <summary>
        /// (Optional) The held payment can be canceled if and only if this field is present and the time it specifies has passed. Specifically, this is specified as seconds since the Ripple Epoch and it "has passed" if it's earlier than the close time of the previous validated ledger.
        /// </summary>
        public DateTimeOffset? CancelAfter { get; private set; }

        /// <summary>
        /// (Optional) The time, in seconds since the Ripple Epoch, after which this held payment can be finished. Any EscrowFinish transaction before this time fails. (Specifically, this is compared with the close time of the previous validated ledger.)
        /// </summary>
        public DateTimeOffset? FinishAfter { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags. No flags are defined for the Escrow type, so this value is always 0.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the source for this held payment, such as a hosted recipient at the owner's address.
        /// </summary>
        public uint? SourceTag { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the destination for this held payment, such as a hosted recipient at the destination address.
        /// </summary>
        public uint? DestinationTag { get; private set; }

        /// <summary>
        /// (Optional) A hint indicating which page of the destination's owner directory links to this object, in case the directory consists of multiple pages. Omitted on escrows created before enabling the fix1523 amendment.
        /// </summary>
        public ulong? DestinationNode { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        internal Escrow(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Escrow")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Escrow\"", "json");
            }
            JsonElement element;

            Account = new AccountId(json.GetProperty("Account").GetString());
            Destination = new AccountId(json.GetProperty("Destination").GetString());
            Amount = Amount.ReadJson(json.GetProperty("Amount"));
            if (json.TryGetProperty("Condition", out element))
            {
                Condition = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("CancelAfter", out element))
            {
                CancelAfter = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("FinishAfter", out element))
            {
                FinishAfter = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            Flags = json.GetProperty("Flags").GetUInt32();
            if (json.TryGetProperty("SourceTag", out element))
            {
                SourceTag = element.GetUInt32();
            }
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
            if (json.TryGetProperty("DestinationNode", out element))
            {
                DestinationNode = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
        }

        internal Escrow(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_CancelAfter)
            {
                CancelAfter = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_FinishAfter)
            {
                FinishAfter = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt64_DestinationNode)
            {
                DestinationNode = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Amount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Amount, fieldId));
            }
            Amount = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.Blob_Condition)
            {
                Condition = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
        }

    }

    /// <summary>
    /// The FeeSettings object type contains the current base transaction cost and reserve amounts as determined by fee voting. Each ledger version contains at most one FeeSettings object.
    /// </summary>
    public sealed partial class FeeSettings : LedgerObject
    {
        /// <summary>
        /// The transaction cost of the "reference transaction" in drops of XRP as hexadecimal.
        /// </summary>
        public ulong BaseFee { get; private set; }

        /// <summary>
        /// The BaseFee translated into "fee units".
        /// </summary>
        public uint ReferenceFeeUnits { get; private set; }

        /// <summary>
        /// The base reserve for an account in the XRP Ledger, as drops of XRP.
        /// </summary>
        public uint ReserveBase { get; private set; }

        /// <summary>
        /// The incremental owner reserve for owning objects, as drops of XRP.
        /// </summary>
        public uint ReserveIncrement { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags for this object. No flags are defined for this type.
        /// </summary>
        public uint Flags { get; private set; }

        internal FeeSettings(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "FeeSettings")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"FeeSettings\"", "json");
            }

            BaseFee = ulong.Parse(json.GetProperty("BaseFee").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            ReferenceFeeUnits = json.GetProperty("ReferenceFeeUnits").GetUInt32();
            ReserveBase = json.GetProperty("ReserveBase").GetUInt32();
            ReserveIncrement = json.GetProperty("ReserveIncrement").GetUInt32();
            Flags = json.GetProperty("Flags").GetUInt32();
        }

        internal FeeSettings(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_ReferenceFeeUnits)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_ReferenceFeeUnits, fieldId));
            }
            ReferenceFeeUnits = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_ReserveBase)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_ReserveBase, fieldId));
            }
            ReserveBase = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_ReserveIncrement)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_ReserveIncrement, fieldId));
            }
            ReserveIncrement = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_BaseFee)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_BaseFee, fieldId));
            }
            BaseFee = reader.ReadUInt64();
        }

    }

    /// <summary>
    /// The LedgerHashes object type contains a history of prior ledgers that led up to this ledger version, in the form of their hashes. Objects of this ledger type are modified automatically in the process of closing a ledger.
    /// </summary>
    public sealed partial class LedgerHashes : LedgerObject
    {
        /// <summary>
        /// The Ledger Index of the last entry in this object's Hashes array.
        /// </summary>
        public uint LastLedgerSequence { get; private set; }

        /// <summary>
        /// An array of up to 256 ledger hashes. The contents depend on which sub-type of LedgerHashes object this is.
        /// </summary>
        public ReadOnlyCollection<Hash256> Hashes { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags for this object. No flags are defined for this type.
        /// </summary>
        public uint Flags { get; private set; }

        internal LedgerHashes(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "LedgerHashes")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"LedgerHashes\"", "json");
            }
            JsonElement element;

            LastLedgerSequence = json.GetProperty("LastLedgerSequence").GetUInt32();
            element = json.GetProperty("Hashes");
            var HashesArray = new Hash256[element.GetArrayLength()];
            for (int i = 0; i < HashesArray.Length; ++i)
            {
                HashesArray[i] = new Hash256(element[i].GetString());
            }
            Hashes = Array.AsReadOnly(HashesArray);
            Flags = json.GetProperty("Flags").GetUInt32();
        }

        internal LedgerHashes(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_LastLedgerSequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_LastLedgerSequence, fieldId));
            }
            LastLedgerSequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Vector256_Hashes)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Vector256_Hashes, fieldId));
            }
            Hashes = Array.AsReadOnly(reader.ReadVector256());
        }

    }

    /// <summary>
    /// The NegativeUNL object type contains the current status of the Negative UNL, a list of trusted validators currently believed to be offline.
    /// </summary>
    public sealed partial class NegativeUNL : LedgerObject
    {
        /// <summary>
        /// (Optional) A list of DisabledValidator objects (see below), each representing a trusted validator that is currently disabled.
        /// </summary>
        public ReadOnlyCollection<DisabledValidator> DisabledValidators { get; private set; }

        /// <summary>
        /// (Optional) The public key of a trusted validator that is scheduled to be disabled in the next flag ledger.
        /// </summary>
        public ReadOnlyMemory<byte>? ValidatorToDisable { get; private set; }

        /// <summary>
        /// (Optional) The public key of a trusted validator in the Negative UNL that is scheduled to be re-enabled in the next flag ledger.
        /// </summary>
        public ReadOnlyMemory<byte>? ValidatorToReEnable { get; private set; }

        internal NegativeUNL(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "NegativeUNL")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"NegativeUNL\"", "json");
            }
            JsonElement element;

            if (json.TryGetProperty("DisabledValidators", out element))
            {
            var DisabledValidatorsArray = new DisabledValidator[element.GetArrayLength()];
            for (int i = 0; i < DisabledValidatorsArray.Length; ++i)
            {
                DisabledValidatorsArray[i] = new DisabledValidator(element[i]);
            }
            DisabledValidators = Array.AsReadOnly(DisabledValidatorsArray);
            }
            if (json.TryGetProperty("ValidatorToDisable", out element))
            {
                ValidatorToDisable = element.GetBytesFromBase16();
            }
            if (json.TryGetProperty("ValidatorToReEnable", out element))
            {
                ValidatorToReEnable = element.GetBytesFromBase16();
            }
        }

        internal NegativeUNL(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId == StFieldId.Blob_ValidatorToDisable)
            {
                ValidatorToDisable = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    return;
                }
            }
            if (fieldId == StFieldId.Blob_ValidatorToReEnable)
            {
                ValidatorToReEnable = reader.ReadBlob();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    return;
                }
            }
            if (fieldId == StFieldId.Array_DisabledValidators)
            {
                var DisabledValidatorsList = new System.Collections.Generic.List<DisabledValidator>();
                while (true)
                {
                    fieldId = reader.ReadFieldId();
                    if (fieldId == StFieldId.Array_ArrayEndMarker)
                    {
                        break;
                    }
                    if (fieldId != StFieldId.Object_DisabledValidator)
                    {
                        throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_DisabledValidator, fieldId));
                    }
                    DisabledValidatorsList.Add(new DisabledValidator(ref reader));
                }
                DisabledValidators = DisabledValidatorsList.AsReadOnly();
            }
        }

    }

    /// <summary>
    /// The Offer object type describes an offer to exchange currencies, more traditionally known as an order, in the XRP Ledger's distributed exchange. An OfferCreate transaction only creates an Offer object in the ledger when the offer cannot be fully executed immediately by consuming other offers already in the ledger.
    /// </summary>
    public sealed partial class Offer : LedgerObject
    {
        /// <summary>
        /// A bit-map of boolean flags enabled for this offer.
        /// </summary>
        public OfferFlags Flags { get; private set; }

        /// <summary>
        /// The address of the account that owns this offer.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The Sequence value of the OfferCreate transaction that created this Offer object. Used in combination with the Account to identify this Offer.
        /// </summary>
        public uint Sequence { get; private set; }

        /// <summary>
        /// The remaining amount and type of currency requested by the offer creator.
        /// </summary>
        public Amount TakerPays { get; private set; }

        /// <summary>
        /// The remaining amount and type of currency being provided by the offer creator.
        /// </summary>
        public Amount TakerGets { get; private set; }

        /// <summary>
        /// The ID of the Offer Directory that links to this offer.
        /// </summary>
        public Hash256 BookDirectory { get; private set; }

        /// <summary>
        /// A hint indicating which page of the offer directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong BookNode { get; private set; }

        /// <summary>
        /// (Optional) Indicates the time after which this offer is considered unfunded. See Specifying Time for details.
        /// </summary>
        public DateTimeOffset? Expiration { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        internal Offer(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Offer")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Offer\"", "json");
            }
            JsonElement element;

            Flags = (OfferFlags)json.GetProperty("Flags").GetUInt32();
            Account = new AccountId(json.GetProperty("Account").GetString());
            Sequence = json.GetProperty("Sequence").GetUInt32();
            TakerPays = Amount.ReadJson(json.GetProperty("TakerPays"));
            TakerGets = Amount.ReadJson(json.GetProperty("TakerGets"));
            BookDirectory = new Hash256(json.GetProperty("BookDirectory").GetString());
            BookNode = ulong.Parse(json.GetProperty("BookNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            if (json.TryGetProperty("Expiration", out element))
            {
                Expiration = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
        }

        internal Offer(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = (OfferFlags)reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_Sequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Sequence, fieldId));
            }
            Sequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_Expiration)
            {
                Expiration = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt64_BookNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_BookNode, fieldId));
            }
            BookNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_BookDirectory)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_BookDirectory, fieldId));
            }
            BookDirectory = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_TakerPays)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_TakerPays, fieldId));
            }
            TakerPays = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_TakerGets)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_TakerGets, fieldId));
            }
            TakerGets = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
        }

    }

    /// <summary>
    /// The PayChannel object type represents a payment channel. Payment channels enable small, rapid off-ledger payments of XRP that can be later reconciled with the consensus ledger. A payment channel holds a balance of XRP that can only be paid out to a specific destination address until the channel is closed. Any unspent XRP is returned to the channel's owner (the source address that created and funded it) when the channel closes.
    /// </summary>
    public sealed partial class PayChannel : LedgerObject
    {
        /// <summary>
        /// The source address that owns this payment channel. This comes from the sending address of the transaction that created the channel.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// The destination address for this payment channel. While the payment channel is open, this address is the only one that can receive XRP from the channel. This comes from the Destination field of the transaction that created the channel.
        /// </summary>
        public AccountId Destination { get; private set; }

        /// <summary>
        /// Total XRP, in drops, that has been allocated to this channel. This includes XRP that has been paid to the destination address. This is initially set by the transaction that created the channel and can be increased if the source address sends a PaymentChannelFund transaction.
        /// </summary>
        public Amount Amount { get; private set; }

        /// <summary>
        /// Total XRP, in drops, already paid out by the channel. The difference between this value and the Amount field is how much XRP can still be paid to the destination address with PaymentChannelClaim transactions. If the channel closes, the remaining difference is returned to the source address.
        /// </summary>
        public Amount Balance { get; private set; }

        /// <summary>
        /// Public key, in hexadecimal, of the key pair that can be used to sign claims against this channel. This can be any valid secp256k1 or Ed25519 public key. This is set by the transaction that created the channel and must match the public key used in claims against the channel. The channel source address can also send XRP from this channel to the destination without signed claims.
        /// </summary>
        public ReadOnlyMemory<byte> PublicKey { get; private set; }

        /// <summary>
        /// Number of seconds the source address must wait to close the channel if it still has any XRP in it. Smaller values mean that the destination address has less time to redeem any outstanding claims after the source address requests to close the channel. Can be any value that fits in a 32-bit unsigned integer (0 to 2^32-1). This is set by the transaction that creates the channel.
        /// </summary>
        public uint SettleDelay { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// A bit-map of boolean flags enabled for this payment channel. Currently, the protocol defines no flags for PayChannel objects.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// (Optional) A hint indicating which page of the destination's owner directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong? DestinationNode { get; private set; }

        /// <summary>
        /// (Optional) The mutable expiration time for this payment channel, in seconds since the Ripple Epoch. The channel is expired if this value is present and smaller than the previous ledger's close_time field. See Setting Channel Expiration for more details.
        /// </summary>
        public DateTimeOffset? Expiration { get; private set; }

        /// <summary>
        /// (Optional) The immutable expiration time for this payment channel, in seconds since the Ripple Epoch. This channel is expired if this value is present and smaller than the previous ledger's close_time field. This is optionally set by the transaction that created the channel, and cannot be changed.
        /// </summary>
        public DateTimeOffset? CancelAfter { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the source for this payment channel, such as a hosted recipient at the owner's address.
        /// </summary>
        public uint? SourceTag { get; private set; }

        /// <summary>
        /// (Optional) An arbitrary tag to further specify the destination for this payment channel, such as a hosted recipient at the destination address.
        /// </summary>
        public uint? DestinationTag { get; private set; }

        internal PayChannel(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "PayChannel")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"PayChannel\"", "json");
            }
            JsonElement element;

            Account = new AccountId(json.GetProperty("Account").GetString());
            Destination = new AccountId(json.GetProperty("Destination").GetString());
            Amount = Amount.ReadJson(json.GetProperty("Amount"));
            Balance = Amount.ReadJson(json.GetProperty("Balance"));
            PublicKey = json.GetProperty("PublicKey").GetBytesFromBase16();
            SettleDelay = json.GetProperty("SettleDelay").GetUInt32();
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            Flags = json.GetProperty("Flags").GetUInt32();
            if (json.TryGetProperty("DestinationNode", out element))
            {
                DestinationNode = ulong.Parse(element.GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            }
            if (json.TryGetProperty("Expiration", out element))
            {
                Expiration = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("CancelAfter", out element))
            {
                CancelAfter = Epoch.ToDateTimeOffset(element.GetUInt32());
            }
            if (json.TryGetProperty("SourceTag", out element))
            {
                SourceTag = element.GetUInt32();
            }
            if (json.TryGetProperty("DestinationTag", out element))
            {
                DestinationTag = element.GetUInt32();
            }
        }

        internal PayChannel(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_SourceTag)
            {
                SourceTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_Expiration)
            {
                Expiration = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_DestinationTag)
            {
                DestinationTag = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_CancelAfter)
            {
                CancelAfter = Epoch.ToDateTimeOffset(reader.ReadUInt32());
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt32_SettleDelay)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_SettleDelay, fieldId));
            }
            SettleDelay = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt64_DestinationNode)
            {
                DestinationNode = reader.ReadUInt64();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Amount)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Amount, fieldId));
            }
            Amount = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Balance)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Balance, fieldId));
            }
            Balance = reader.ReadAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Blob_PublicKey)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Blob_PublicKey, fieldId));
            }
            PublicKey = reader.ReadBlob();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Destination)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Destination, fieldId));
            }
            Destination = reader.ReadAccount();
        }

    }

    /// <summary>
    /// The RippleState object type connects two accounts in a single currency. Conceptually, a RippleState object represents two trust lines between the accounts, one from each side. Each account can change the settings for its side of the RippleState object, but the balance is a single shared value. A trust line that is entirely in its default state is considered the same as a trust line that does not exist, so rippled deletes RippleState objects when their properties are entirely default.
    /// </summary>
    public sealed partial class RippleState : LedgerObject
    {
        /// <summary>
        /// A bit-map of boolean options enabled for this object.
        /// </summary>
        public RippleStateFlags Flags { get; private set; }

        /// <summary>
        /// The balance of the trust line, from the perspective of the low account. A negative balance indicates that the low account has issued currency to the high account. The issuer in this is always set to the neutral value ACCOUNT_ONE.
        /// </summary>
        public IssuedAmount Balance { get; private set; }

        /// <summary>
        /// The limit that the low account has set on the trust line. The issuer is the address of the low account that set this limit.
        /// </summary>
        public IssuedAmount LowLimit { get; private set; }

        /// <summary>
        /// The limit that the high account has set on the trust line. The issuer is the address of the high account that set this limit.
        /// </summary>
        public IssuedAmount HighLimit { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// (Omitted in some historical ledgers) A hint indicating which page of the low account's owner directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong LowNode { get; private set; }

        /// <summary>
        /// (Omitted in some historical ledgers) A hint indicating which page of the high account's owner directory links to this object, in case the directory consists of multiple pages.
        /// </summary>
        public ulong HighNode { get; private set; }

        /// <summary>
        /// (Optional) The inbound quality set by the low account, as an integer in the implied ratio LowQualityIn:1,000,000,000. As a special case, the value 0 is equivalent to 1 billion, or face value.
        /// </summary>
        public uint? LowQualityIn { get; private set; }

        /// <summary>
        /// (Optional) The outbound quality set by the low account, as an integer in the implied ratio LowQualityOut:1,000,000,000. As a special case, the value 0 is equivalent to 1 billion, or face value.
        /// </summary>
        public uint? LowQualityOut { get; private set; }

        /// <summary>
        /// (Optional) The inbound quality set by the high account, as an integer in the implied ratio HighQualityIn:1,000,000,000. As a special case, the value 0 is equivalent to 1 billion, or face value.
        /// </summary>
        public uint? HighQualityIn { get; private set; }

        /// <summary>
        /// (Optional) The outbound quality set by the high account, as an integer in the implied ratio HighQualityOut:1,000,000,000. As a special case, the value 0 is equivalent to 1 billion, or face value.
        /// </summary>
        public uint? HighQualityOut { get; private set; }

        internal RippleState(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "RippleState")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"RippleState\"", "json");
            }
            JsonElement element;

            Flags = (RippleStateFlags)json.GetProperty("Flags").GetUInt32();
            Balance = IssuedAmount.ReadJson(json.GetProperty("Balance"));
            LowLimit = IssuedAmount.ReadJson(json.GetProperty("LowLimit"));
            HighLimit = IssuedAmount.ReadJson(json.GetProperty("HighLimit"));
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            LowNode = ulong.Parse(json.GetProperty("LowNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            HighNode = ulong.Parse(json.GetProperty("HighNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            if (json.TryGetProperty("LowQualityIn", out element))
            {
                LowQualityIn = element.GetUInt32();
            }
            if (json.TryGetProperty("LowQualityOut", out element))
            {
                LowQualityOut = element.GetUInt32();
            }
            if (json.TryGetProperty("HighQualityIn", out element))
            {
                HighQualityIn = element.GetUInt32();
            }
            if (json.TryGetProperty("HighQualityOut", out element))
            {
                HighQualityOut = element.GetUInt32();
            }
        }

        internal RippleState(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = (RippleStateFlags)reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId == StFieldId.UInt32_HighQualityIn)
            {
                HighQualityIn = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_HighQualityOut)
            {
                HighQualityOut = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LowQualityIn)
            {
                LowQualityIn = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId == StFieldId.UInt32_LowQualityOut)
            {
                LowQualityOut = reader.ReadUInt32();
                if (!reader.TryReadFieldId(out fieldId))
                {
                    throw new Exception("End of st data reached but non-optional fields still not set");
                }
            }
            if (fieldId != StFieldId.UInt64_LowNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_LowNode, fieldId));
            }
            LowNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_HighNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_HighNode, fieldId));
            }
            HighNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_Balance)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_Balance, fieldId));
            }
            Balance = reader.ReadIssuedAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_LowLimit)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_LowLimit, fieldId));
            }
            LowLimit = reader.ReadIssuedAmount();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Amount_HighLimit)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Amount_HighLimit, fieldId));
            }
            HighLimit = reader.ReadIssuedAmount();
        }

    }

    /// <summary>
    /// The SignerList object type represents a list of parties that, as a group, are authorized to sign a transaction in place of an individual account. You can create, replace, or remove a signer list using a SignerListSet transaction.
    /// </summary>
    public sealed partial class SignerList : LedgerObject
    {
        /// <summary>
        /// A bit-map of Boolean flags enabled for this signer list. For more information, see SignerList Flags.
        /// </summary>
        public SignerListFlags Flags { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        /// <summary>
        /// An array of Signer Entry objects representing the parties who are part of this signer list.
        /// </summary>
        public ReadOnlyCollection<SignerEntry> SignerEntries { get; private set; }

        /// <summary>
        /// An ID for this signer list. Currently always set to 0. If a future amendment allows multiple signer lists for an account, this may change.
        /// </summary>
        public uint SignerListID { get; private set; }

        /// <summary>
        /// A target number for signer weights. To produce a valid signature for the owner of this SignerList, the signers must provide valid signatures whose weights sum to this value or more.
        /// </summary>
        public uint SignerQuorum { get; private set; }

        internal SignerList(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "SignerList")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"SignerList\"", "json");
            }
            JsonElement element;

            Flags = (SignerListFlags)json.GetProperty("Flags").GetUInt32();
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
            element = json.GetProperty("SignerEntries");
            var SignerEntriesArray = new SignerEntry[element.GetArrayLength()];
            for (int i = 0; i < SignerEntriesArray.Length; ++i)
            {
                SignerEntriesArray[i] = new SignerEntry(element[i]);
            }
            SignerEntries = Array.AsReadOnly(SignerEntriesArray);
            SignerListID = json.GetProperty("SignerListID").GetUInt32();
            SignerQuorum = json.GetProperty("SignerQuorum").GetUInt32();
        }

        internal SignerList(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = (SignerListFlags)reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_SignerQuorum)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_SignerQuorum, fieldId));
            }
            SignerQuorum = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_SignerListID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_SignerListID, fieldId));
            }
            SignerListID = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Array_SignerEntries)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Array_SignerEntries, fieldId));
            }
            var SignerEntriesList = new System.Collections.Generic.List<SignerEntry>();
            while (true)
            {
                fieldId = reader.ReadFieldId();
                if (fieldId == StFieldId.Array_ArrayEndMarker)
                {
                    break;
                }
                if (fieldId != StFieldId.Object_SignerEntry)
                {
                    throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Object_SignerEntry, fieldId));
                }
                SignerEntriesList.Add(new SignerEntry(ref reader));
            }
            SignerEntries = SignerEntriesList.AsReadOnly();
        }

    }

    /// <summary>
    /// The Ticket object type represents a Ticket, which tracks an account sequence number that has been set aside for future use. You can create new tickets with a TicketCreate transaction. New in: rippled 1.7.0 
    /// </summary>
    public sealed partial class Ticket : LedgerObject
    {
        /// <summary>
        /// The account that owns this Ticket.
        /// </summary>
        public AccountId Account { get; private set; }

        /// <summary>
        /// A bit-map of Boolean flags enabled for this Ticket. Currently, there are no flags defined for Tickets.
        /// </summary>
        public uint Flags { get; private set; }

        /// <summary>
        /// The Sequence Number this Ticket sets aside.
        /// </summary>
        public uint TicketSequence { get; private set; }

        /// <summary>
        /// A hint indicating which page of the sender's owner directory links to this object, in case the directory consists of multiple pages. Note: The object does not contain a direct link to the owner directory containing it, since that value can be derived from the Account.
        /// </summary>
        public ulong OwnerNode { get; private set; }

        /// <summary>
        /// The identifying hash of the transaction that most recently modified this object.
        /// </summary>
        public Hash256 PreviousTxnID { get; private set; }

        /// <summary>
        /// The index of the ledger that contains the transaction that most recently modified this object.
        /// </summary>
        public uint PreviousTxnLgrSeq { get; private set; }

        internal Ticket(JsonElement json)
        {
            if (json.GetProperty("LedgerEntryType").GetString() != "Ticket")
            {
                throw new ArgumentException("Expected property \"LedgerEntryType\" to be \"Ticket\"", "json");
            }

            Account = new AccountId(json.GetProperty("Account").GetString());
            Flags = json.GetProperty("Flags").GetUInt32();
            TicketSequence = json.GetProperty("TicketSequence").GetUInt32();
            OwnerNode = ulong.Parse(json.GetProperty("OwnerNode").GetString(), System.Globalization.NumberStyles.AllowHexSpecifier);
            PreviousTxnID = new Hash256(json.GetProperty("PreviousTxnID").GetString());
            PreviousTxnLgrSeq = json.GetProperty("PreviousTxnLgrSeq").GetUInt32();
        }

        internal Ticket(ref StReader reader)
        {
            StFieldId fieldId = reader.ReadFieldId();
            if (fieldId != StFieldId.UInt32_Flags)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_Flags, fieldId));
            }
            Flags = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_PreviousTxnLgrSeq)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_PreviousTxnLgrSeq, fieldId));
            }
            PreviousTxnLgrSeq = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt32_TicketSequence)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt32_TicketSequence, fieldId));
            }
            TicketSequence = reader.ReadUInt32();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.UInt64_OwnerNode)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.UInt64_OwnerNode, fieldId));
            }
            OwnerNode = reader.ReadUInt64();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.Hash256_PreviousTxnID)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.Hash256_PreviousTxnID, fieldId));
            }
            PreviousTxnID = reader.ReadHash256();
            if (!reader.TryReadFieldId(out fieldId))
            {
                throw new Exception("End of st data reached but non-optional fields still not set");
            }
            if (fieldId != StFieldId.AccountID_Account)
            {
                throw new Exception(string.Format("Expected {0} but got {1}", StFieldId.AccountID_Account, fieldId));
            }
            Account = reader.ReadAccount();
        }

    }

}

